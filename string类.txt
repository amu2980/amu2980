/*****************************************************************************************
string类型：c++中新增的数据类型，用于优化C语言在字符串处理不便，string类型的相关操作及其处
	理函数等可#include <string>头实现，同时string类型也对相应运算符进行了重载以下介绍相应
	的处理方法，string类中的常用函数可分类为：1.构造 2.追加 3.赋值 4.位置与清除 5.长度与容量
	6.比较 7.子串 8.搜索 9.运算符

1.string类的几种初始化（构造函数调用）：
	1.1.string str：生成空字符串
	1.2.string s(str)：生成字符串为str的复制品
	1.3.string s(str, strbegin,strlen)：将字符串str中从下标strbegin开始、长度为strlen的部分
		作为字符串初值
	1.4.string s(cstr, char_len)：以C_string类型cstr的前char_len个字符串作为字符串s的初值
	1.5.string s(num ,c)：生成num个c字符的字符串
	1.6.string s(str, stridx)：将字符串str中从下标stridx开始到字符串结束的位置作为字符串初
		值 
	e.g:	string str1;               //生成空字符串
			string str2("123456789");  //生成"1234456789"的复制品
			string str3("12345", 0, 3);//结果为"123"
			string str4("012345", 5);  //结果为"01234"
			string str5(5, '1');       //结果为"11111"
			string str6(str2, 2);      //结果为"3456789"

2.大小和容量函数：
	2.1.size()和length()：二者完全一致，返回string对象的字符个数
	2.2.max_size()：返回string对象最多可包含的字符数，超出会抛出length_error异常
	2.3.capacity()：重新分配内存之前，string对象能包含的最大字符数

	e.g:	string str("12345");
			cout << str.size() << endl;         //(输出)-->5
			cout << str.length() << endl;			  //-->5
			cout << str.max_size() << endl;           //-->2147483647
			cout << str.capacity() << endl;           //-->15

3.比较：相较于C语言的strcmp函数，c++直接重载了许多运算符用于字符串的比较
	1. C++字符串支持常见的比较操作符（>,>=,<,<=,==,!=），甚至支持string与C-string的比较
	(如 str<”hello”)。  在使用>,>=,<,<=这些操作符的时候是根据“当前字符特性”将字符按字
	典顺序进行逐一地比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字
	符就按这个位置上的两个字符的比较结果确定两个字符串的大小(前面减后面)，同时，string (
	“aaaa”) <string(aaaaa)。
	2. 另一个功能强大的比较函数是成员函数compare()。strcmp的上位替代，他支持多参数处理，支
		持用索引值和长度定位子串来进行比较。 他返回一个整数来表示比较结果，返回值意义如下：
			0：相等					1：大于					 -1：小于)
	由于具有多个重载，故可以实现的调用形式总结为：
		string_obj1.compare(int_1,int_2,string_obj2,int_3,int_4);
	①其中string_obj2参数必须给出，可以是string对象，同时也可以是字符串常量或字符数组
	②第1,2,4,5的int类型的参数可以选择性给出，分别表示意义如下
		int_1 : string_obj1中第int_1+1（类似下标从零开始）个元素开始参与比较
		int_2 : string_obj1中参与比较的元素的个数
		int_3 : string_obj2中第int_1+1个元素开始参与比较
		int_4 : string_obj2中参与比较的元素的个数

	e.g:	string str1 = "123", str2 = "345";
			"123" < "345";                          //true
			"123" <= "345";                         //true
			"123" == "345";                         //false
			str1  == "123";                         //true
			str1.compare(str2);                     //-1
			str1.compare(2,1,str2,0,1);             //0(str1中"3"和str2中"3"比较)

4.string插入与拼接：
	4.1.push_back(char)：在string_obj尾部插入一个字符
	4.2.insert(pos,char)：在指定位置pos前插入一个字符
	4.3.append(string_obj/const char*)：将string_obj或const char*拼接到该对象尾部
	4.4.operator += 和 + 重载：隐式调用append函数

	e.g.	string str1 = "123",str2 = "345";
			str1.push_back('4');                     //str1=="1234"
			str1.insert(str1.begin(),'4');           //str1=="4123"
			str1.append("456");                      //str1=="123456"
			str1.append(str2);                       //str1=="123456"
			str1 += "456";                           //str1=="123456"

5.string的遍历： 
	5.1.下标法：与字符数组相同
				e.g.	string str = "12345";
						for(int i = 0 ; i < str.size() ; i++){cout << str[i];}
				//-->12345
	5.2.迭代器：
		5.2.1.正向迭代器
				e.g.
						string::iterator iter = s1.begin();
						for( ; iter < s1.end() ; iter++){
					       cout<<*iter; }
				//-->12345

		5.2.2.反向迭代器
				e.g.
					   string::reverse_iterator riter = s1.rbegin();
					   for( ; riter < s1.rend() ; riter++){
					       cout<<*riter; }
				//-->54321

6.string中的删除：erase()函数，常用重载如下：
	6.1.iterator erase(iterator p);							//删除字符串中p所指的字符
	6.2.iterator erase(iterator first, iterator last);		//删除字符串中迭代器区间[first,
															  last)上所有字符
	6.3.string& erase(size_t pos = 0, size_t len = npos);	//删除字符串中从索引位置（下标）
																pos开始的len个字符
	6.4.void clear();										//删除字符串中所有字符

	e.g:	string str("123");
			str.erase(str.begin()+1);					//str=="13"
			str.erase(str.begin(),str.end()-1);			//str=="3"
			str.erase(1,2);								//str=="1"
			str.clear();								//str==""

7.string字符的替换：replace()函数，常用重载如下：
	7.1.string& replace(size_t pos, size_t n, const char *s);
							//将当前字符串从pos索引（下标）开始的n个字符，替换成字符串s
	7.2.string& replace(size_t pos, size_t n, size_t n1, char c);
							//将当前字符串从pos索引（下标）开始的n个字符，替换成n1个字符c
	7.3.string& replace(iterator i1, iterator i2, const char* s);
							//将当前字符串[i1,i2)区间中的字符串替换为字符串s

		e.g.	string str("hello,world!");
				str.replace(0,5,"welcome");					 //str=="welcome,world!"
				str.replace(5,1,1,' ');						 //str=="hello world!"
				str.replace(str.end()-6,str.end()-1,"guy");  //str=="hello,guy!"

8.string查找：
	8.1.size_t find (constchar* s, size_t pos = 0) const;
		//在当前字符串的pos索引位置开始，查找子串s，返回找到的位置索引，-1表示查找不到子串
	8.2.size_t find (charc, size_t pos = 0) const;
		//在当前字符串的pos索引位置开始，查找字符c，返回找到的位置索引，-1表示查找不到字符
	8.3.size_t rfind (constchar* s, size_t pos = npos) const;
		//在当前字符串的pos索引位置开始，反向查找子串s，返回找到的位置索引，-1表示查找不到
		子串
	8.4.size_t rfind (charc, size_t pos = npos) const;
		//在当前字符串的pos索引位置开始，反向查找字符c，返回找到的位置索引，-1表示查找不到
		字符
	8.5.size_tfind_first_of (const char* s, size_t pos = 0) const;
		//在当前字符串的pos索引位置开始，查找子串s的字符，返回找到的位置索引，-1表示查找不
		到字符
	8.6.size_tfind_first_not_of (const char* s, size_t pos = 0) const;
		//在当前字符串的pos索引位置开始，查找第一个不位于子串s的字符，返回找到的位置索引，
		-1表示查找不到字符
	8.7.size_t find_last_of(const char* s, size_t pos = npos) const;
		//在当前字符串的pos索引位置开始，查找最后一个位于子串s的字符，返回找到的位置索引，
		-1表示查找不到字符
	8.8.size_tfind_last_not_of (const char* s, size_t pos = npos) const;
		//在当前字符串的pos索引位置开始，查找最后一个不位于子串s的字符，返回找到的位置索
		引，-1表示查找不到子串

9.以下列出各类中的常用函数：
	9.1. 构造一个空字符串							string（）
	9.2. 由指定的字符串常量构造一个字符串			string（string value）
	9.3. 由指定的字符串数组构造一个字符串			string（char[] value）
	9.4. 构造一个字符串且初值为n个指定字符			string（char ch，int n）
	
	9.5. 将字符串s追加在当前string后				append（string s）：[返回] string
	9.6. 将s中从index起的n个字符追加在当前string后	append（string s，int index，int n）：string
	9.7. 将s的前n个字符追加在当前string后			append（char[] s，int n）：string
	9.8. 将n个字符追加在当前string后				append（int n，char ch）：string

	9.9. 将一个字符数组或字符串s赋值当前string		assign（char[] s）：string
	9.10.将s中从index起的n个字符赋值当前string		assign（string s，int index，int n）：string
	9.11.将s的前n个字符赋值当前string				assign（string s，int n）：string
	9.12.将当前string赋值为n个字符					assign（int n，char ch）：string

	9.13.返回当前string index处的字符				at（int index）：char

	9.14.返回当前string长度							size（）：int  或 length（）：int
	9.15.返回为当前string分配的储存空间大小			capacity（）：int
	
	9.16.清除当前string所有字符						clear（）：void

	9.17.删除当前string从index开始的n个字符			erase（int index，int n）：string
	
	9.18.若当前string为空返回true					empty（）：bool

	9.19.比较string，同C语言strcmp函数				compare（string s）：int
	9.20.与另一个string的index起n个字符相比较		compare（int index，int n，string s）：int
	
	9.21.将当前string从index开始的n个字符赋值到s	copy（char[] s，int n，int index）：void

	9.22.将当前string以一个字符数组返回				data（）：char*

	9.23.返回当前string从index开始的n个字符的子串	substr（int index，int n）：string
	9.24.返回当前string从index开始到最后的子串		substr（int index）：string

	9.25.交换当前string和另一个string的内容			swap（string s）：void

	9.26.返回当前string中字符ch出现的第一个位置		find（char ch）：int
	9.27.当前string中从index开始ch出现的第一个位置	find（char ch，int index）：int
	9.28.返回当前string中子串s出现的第一个位置		find（string s）：int
	9.29.当前string从index开始子串s出现的第一个位置	find（string s，int index）：int

	9.30.当前string从index开始的n个字符替换为子串s	replace（int index，int n，string s）：string

	9.31.把字符串s插入到当前string的index处			insert（int index，string s）：string
	9.32.把n个字符ch插入到当前string的index处		insert（int index，int n，char ch）：string

注1：【迭代器】
（1）迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一
	些操作符，->, * ,++, --等封装了指针，是一个“可遍历STL（ Standard Template Library）容
	器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了
	比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，C
	等操作；
（2）迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接
	输出其自身。
（3）在设计模式中有一种模式叫迭代器模式，简单来说就是提供一种方法，在不需要暴露某个容器的内
	部表现形式情况下，使之能依次访问该容器中的各个元素，这种设计思维在STL中得到了广泛的应用
	，是STL的关键所在，通过迭代器，容器和算法可以有机的粘合在一起，只要对算法给予不同的迭代
	器，就可以对不同容器进行相同的操作。


注2：c++中的“data”中data被理解为字面量常量，类型为const char[]的类型，而“data”s中的data
被理解为string类的字符串，原因是c++对“”s进行了重载，故此在考虑使用字符数组的形式还是string
的形式的时候可以采用不同的方式给出，如;
				auto c = "data";             //c为const char*
				auto q = "data"s;            //q为string
******************************************************************************************/