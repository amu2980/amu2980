/***************************************************************************************
运算符重载：运算符具有多态性，即同一使用方式实际调用不同的过程进行处理的这一性质，而多态
	性的体现有在编译时和在运行时两种，前者如函数的重载和运算符的重载，后者如虚函数

1.1.一般运算符重载用于自定义的类，使自定义的类对象可以像基本数据类型一样的方式通过运算符
	进行基本运算的处理（如+、-、*、/），而不用采用专门定义相应处理的成员函数用以调用

1.2.定义格式：<返回类型> operator <运算符> (形参1，形参2,...) {......}
	(e.g：Myclass operator + (Myclass& a,Myclass& b) {...})

1.3.一般单目运算符定义为类的成员函数，双目运算符定义为类的友元函数，需要对形参存在隐式转
	换功能的定义为友元函数，并且友元函数为了便于运行效率和节约空间，形参和返回值一般采用
	对象引用（部分运算符只能定义为成员函数：= , () , [] , ->）

1.4.定义为成员函数的运算符重载在实际调用时，运算符左侧必须显式保证为重载的参数类型，为其
	他类型时虽然可以通过强制类型转换操作，更好还是将其定义为友元函数利用普通函数的隐式转
	换功能

1.5.运算符重载只能定义原有存在的运算符，不可定义新的运算符，运算符重载不要人为歧义性定义
	（如把+实际定义为相减操作），以及，部分运算符也不能定义重载：:: , # , ?: , . , & , *

1.6.占位参数，在定义++,--这两类单目运算符的重载时，需要考虑到前置和后置，直接定义下默认为
	前置，在定义后置时应在形参中增加占位参数（<返回类型> operator ++ (形参1，int)这里的int
	就是占位参数），占位参数在调用时并不实际传递参数，指对编译器起到说明作用，可定义为成员
	函数和友元函数，当定义为成员函数时由于函数体中并没有显式参数的传递进去，故返回值可以
	使用this指针以 return *this 的形式返回

1.7.对于重载运算符的调用可以采用隐式调用和显式调用两种形式（e.g: 如在定义了Myclass类的+重
	载后，对于对象Myclass a,b,c;执行加法操作可以采用 a = b + c 的隐式调用，亦可以采用 a = 
	operator+(b,c) 或 a = b.operator(c) 的显式调用[前者是定义为友元函数的调用，后者是定义
	为成员函数的调用]）

1.8.输出流运算符的重载需要使用输出流对象ostream，返回值应该是ostream &即输出流对象的引用，
	使下一个数据依旧能够继续输出，输出运算符应定义为友元函数

1.9.一般不需要对赋值运算符进行重载，在定义类的时候回默认生成默认的赋值运算符重载，同默认
	的拷贝构造函数一样采用位拷贝的方式进行复制，但当类中涉及动态空间的分配时，默认的赋值
	运算符就会出错（由于位拷贝是绝对拷贝，故会将右值中储存的指向分配空间的地址赋值给左值
	，左值原有空间指向丢失，左值与右值指向同一空间，在释放时也会出错），故同拷贝构造函数
	一样，当类中涉及到动态空间的分配时，就需要自定义
	
注：不同于拷贝构造函数，赋值运算符重载还需要考虑自己给自己赋值的情况

1.10.虽然拷贝构造函数也可以使用=调用赋值，但区别于赋值运算符在于，拷贝构造函数仅在对象声
	明初始化时调用，而赋值运算符重载函数则是对已经存在的对象进行赋值时调用。

1.11.对于重载函数的返回值，无论友元函数还是成员函数，当返回值可能需要再次作为左值使用时返
	回对象引用，否则返回对象本身，如赋值运算符的重载返回对象引用，以便使赋值运算后的返回
	值依旧可以作为左值，而诸如+、-、*、/、++、--等运算则直接返回对象本身

注1：赋值运算符重载的返回值应固定为左值的引用，即return *this，否则将无法处理连续赋值的
	情况,赋值运算符的形参应该定义为对象的引用，且必须以const关键字修饰，否则在调用时报错
****************************************************************************************/