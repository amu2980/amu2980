/******************************************************************************************
using关键字：
1.命名空间及其成员的导入：

	1.1.直接导入整个命名空间：
		e.g.	using namespace space_NAME（如	using namespace std;）
		（注： 不要在同一程序中引入两个及以上的命名空间）

	1.2.导入某一命名空间的单个成员：
		e.g.	using namespace space_NAME::space_MEMBER （如 using namespace std::cout;）

注意：在程序中并不建议使用using关键字引入整个命名空间，容易导致不可预料的错误，故习惯使用
	namespace_NAME::namespace_MEMBER 的形式调用空间成员是个好习惯

2.为类型创建别名（可替代但不限于typedef）：以下两种声明等价

	typedef double Dou;            <==>              using Dou = double;

	2.1.与typedef的异同：using关键字和typedef关键字在为类型创建别名的时候几乎是完全等价的，
	不同之处在于using关键字还可以为c++中新出现的模板创建别名，而typedef不可以（注意这里是
	指为模板本身（函数模板、类模板）创建别名，而不是对模板定义好的类型（模板函数，模板类
	），因为当为类型创建别名时，typedef依旧可以胜任）：
	e.g.	

注意：在考虑使用using去替代typedef的时候几乎可以忽略他们的细微差异，哪怕他们在特定场合确实
	存在些许的不同，如：using和typedef都可以为函数指针类型创建别名，但typedef还可以为函数类
	型本身创建别名，而using不可以

		e.g.	typedef void(*pfun)(int, int);            √
				using pfun = void(*)(int, int);           √
				typedef void(pfun)(int, int);             √
				using pfun = void()(int, int);            ×

	而这一性质显得并不是那么重要，因为基本没有人回去为特定的函数类型本身创建别名，然后在使
	用时再加上*让他成为指针。

3.改变派生类中的基类成员对外的访问权限：派生类在对于基类成员继承的过程中，所继承的基类成员
	对外的访问权限遵循默认的继承规则，对于那些继承后在派生类中对外不可见的基类成员，可以
	通过using关键字将其改为public（当然，也可以将继承后为public的基类成员改为对外不可见的成
	员（private或protected））

	3.1.方法：在相应访问权限的说明符（如 public：）后声明：
		using base_class_name :: base_member;

	3.2.注意：using关键字是改变某基类成员对外部的可见性，不能改变派生类内部对基类成员的可见
		性，如基类的私有成员在任意继承后对于派生类本身都是不可访问的，也不能使用using关键字
		是这些成员对内或对外可见

4.实现在派生类中定义基类成员函数的重载：正常情况下在派生类中定义基类的同名成员函数，则基类
	中的所有同名成员函数（即同名函数及其所有的重载）在派生类中都将被隐藏，即通过派生类对象
	直接调用该函数时默认调用派生类中的函数且无法使用基类中的重载，如果只是希望在派生类中增
	加该函数的重载或者只是替换基类多个重载中的某几个而使其余重载不被隐藏，除了在派生类中将
	所有的重载再写一遍之外，还可以使用using关键字将基类的成员函数直接导入到派生类中（实际上，
	这一性质也可以理解为第一点性质，即将基类看成是一个命名空间，使用using关键字将该空间中的
	某函数及其所有重载直接导入到派生类中）

	4.1.方法：同3.点，且可同时实现3.点中的性质（即就3.点而言，在与默认的对外访问权限相同的
		权限说明后使用using并不是无意义的，可能只是为了新定义的同名函数不会隐藏基类的函数，
		而不是为了改变该函数的对外访问权限）

	4.2.使用using关键字声明将基类成员函数导入到派生类中后，在派生类中新定义的同名函数会根据
		下列情况作不同处理：

		4.2.1.新定义的同名函数若满足函数重载的要求（仅限于形参数量或类型的不同），则会视为
		新定义的该函数重载，且该重载仅在派生类中有效，对于基类对象而言并不增加该重载

		4.2.2.新定义的同名函数不满足函数重载的要求：

			4.2.2.1.新定义的函数头与基类函数完全一致，且基类该函数没有使用virtual关键字：
			新定义的该函数将完全替换引入的重载中完全一致的那个基类函数（不会像普通函数一样
			出现重定义报错，同时与虚函数的重写也有点相似，但并不具有虚函数的性质）

			4.2.2.2.新定义的函数头与基类函数完全一致，但基类该函数有使用virtual关键字：
			按照虚函数的重写处理，同时其余引入的重载不受影响

			4.2.2.3.新定义的函数与重载中的某个仅返回值的不同：
			新定义的该函数将完全替换引入的重载中仅返回值不同的那个基类函数

5.基类构造函数的继承：实际上，这一性质是基于第四点性质推演出来的，即对基类的所有构造函数进行
导入，但与普通的成员函数导入的处理过程有些许的不同：

	5.1.意义：当派生类中没有派生成员需要被初始化时，可以考虑直接继承基类的构造函数，则可以不用
	在派生类中再定义构造函数对基类成员进行初始化了，如：

									class base{
									public:
										int a,b,c;
										base(){//...}                              //[1]
										base(int a_, int b_, int c_){//...}        //[2]
										base(base& obj){//...}                     //[3]
									};
									class derive : public base{
									public:
										using base::base;         //①声明格式
										void show(){//...}
									};
	注意到在派生类中没有派生部分的成员需要初始化，即只需要对基类成员初始化，则可以采用构造
	函数的继承，即①所在行的声明格式，其表示声明将其基类的构造函数全部导入为自己的构造函数
	（不可以选择导入单个构造函数），其具体实现为：
		
		1)将所有基类的构造函数[1][2][3]导入到声明处
		2)然后将构造函数名替换为自己的类名（不同于普通成员函数的导入）
		3)接着在初始化列表处声明调用基类构造函数（对基类成员进行初始化的实际行为）
				即上述过程完成后的①处代码等价为：

								derive():base(){//...}
								derive(int a_, int b_, int c_):base(a_,b_,c_){//...}
								derive(derive& obj):base(obj){//...}

	5.2.如果在导入基类构造函数后又自行定义了一个构造函数会怎样？同第四点中成员函数的导入后再
	定义的情况相同，如果新定义的构造函数满足重载的条件则视为一个新的构造函数的重载，如果不满
	足，即与导入的某个构造函数完全一致时会被视为对其的重写（注意：这里不存在像成员函数导入后
	再定义时如果仅返回值不同的重定义报错问题，因为构造函数不存在返回值）


constexpr关键字：用于替代C语言中的常量的宏定义，或部分情况下c++中的const

	1.常量：c++中常量的概念分为编译期常量和运行期常量：

		编译期常量：编译时就能确定的常量，是绝对的常量
			e.g.		const int n = 5;

		运行期常量：等到运行时才能确定，是伪装的常量，很多情况下无法作为常量使用
			e.g.		int mm = 5;
						const int m = mm;
		
		当上述第二种情况下的m用于诸如定义数组时（int arr[m];)就会报错，而前者n则不会
	
	2.意义：虽然大多情况下c++中的关键字const可以实现替换C语言中常量的宏定义，但是部分情况
	下存在问题，诸如上述不同时期的常量的问题，即由const定义的常量既有可能是编译期的常量也
	有可能是运行期的常量，而后者几乎无法作为常量使用，故const无法很好的替代define，于是引入
	关键字constexpr（即 const expression），用法同const，但其定义的常量是绝对的编译期的常量
	故可以很好的替代宏定义
*******************************************************************************************/