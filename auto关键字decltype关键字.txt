/*****************************************************************************************
1.auto关键字：虽然c++大部分继承了C语言，但在c++11中对auto关键字重新进行了定义，C语言中auto
	关键字同static一样为变量显式声明其生存期，对于局部变量的声明自动省略了auto，如int a等价
	auto int a;故auto关键字在C语言中几乎很难用到，于是c++11给出重新的定义用于代码：

	1.1.作用：auto关键字用于声明自动根据其赋值类型而选择其类型的变量，如声明auto a = 1;将
		自动识别赋值1（int）而声明a为int类型的变量，声明char ch; auto cc = ch;将会声明cc为
		与ch相同的类型(char)同时将ch的值赋给cc，该机制属于编译时的多态

	1.2.格式：
		1.2.1.如一般数据类型一样放在所声明变量的前面，但必须在声明的同时进行赋值，即auto必
		须是依靠其赋值的类型来确定其变量的类型的（类似Python）

		1.2.2.由一个auto声明在同一行的所有变量必须为同一类型的赋值或可隐式转换为同一类型（
		如auto a = 1,b = 2），否则报错（如auto a = "this",b = 56,c = 'a'）

		1.2.3.对于普通常量的赋值可以通过加上后置类型说明符来显式说明赋值的类型，避免auto发
		生与期望不一致的理解，如：auto x = 1.F;(说明这里的常量1是float而不是int，当然更好的
		方法是赋值1.0)，类似后置说明符有(大小写兼容)：
		.F(float),L(long),LL(long long),UL(unsigned long),ULL(unsigned long long)...

	1.3.限制：auto可用于函数的返回值，但不可用于形参的声明，若希望形参也具有类似的多态可采
		用函数模板

	1.4.特性：
		1.4.1.值得注意的是对于声明const int x = 0; auto y = x;并不能达到理想预期，即auto并
		不会声明y为const int类型，而将其声明为int类型，这取决与auto的特性，即auto进行自动识
		别时会忽略赋值数据的类型中的const和&(引用)，解决这一问题的办法就是声明变量为auto&,
		即对于上述的y将其声明为auto& y = x;就可以间接达到理想的预期（间接是指这里并不是直接
		能够将y声明为const int，而是通过显式将auto声明为引用(auto&)从而由原来自动推导的int
		变为int&，同时赋值的实质也就由赋值变为引用的初始化了）

		1.4.2.auto无法用于新数组的创建，因为，对于数组类型的推导，auto在声明时会将作为赋值
		数据的数组名退化为指针并且将首地址赋给新变量，而不是声明一个与赋值数组同类型的数组,
		而如果采用auto&方式声明，则会创建赋值数组的引用，也不能达到目的

2.dectype关键字：c++中decltype关键字用于使用已有变量声明新的变量

	2.1.格式：decltype(variavle_NAME) new_variable_NAME;
		e.g.	int a = 5;	decltype(a) b;  //b声明为int

	2.2.与auto的区别：

		2.2.1.auto声明变量原理是根据其赋值变量的类型声明相同类型的新变量，decltype的原理是
		根据括号中的变量的类型声明相同类型的新变量，故auto声明时会且必须对新变量进行赋值，
		而decltype可以不进行赋值

		2.2.2.decltype不具有auto的特性，即推导不会默认略过const和&，数组也不会默认退化为指
		针
			e.g.	const int a = 5; decltype(a) b; 
				//b声明为const int， 而 auto b = a;的b声明为int

		2.2.3.decltype显式指定声明为引用与auto方式不同，声明格式为双重括号：
			e.g.	int a = 5; decltype((a)) b;        //b声明为int &
				//注意这里应当对b赋初值，否则报错（引用必须初始化）

		2.2.4.decltype无法用于函数返回值和形参，auto可以用于函数返回值



注：输出变量的类型可以借用typeid(variable_NAME).name()函数得到类型，然后用cout输出，typeid
	包含在头<typeinfo>中，注意，上述方式无法正确输出引用，仅会输出与所引用变量相同的类型
	（实际上应该是取决于引用本身的性质，理解为引用类型仅在声明时存在，一旦绑定成功，则后续
	会被直接视为与所引用变量完全一致的类型，且表示完全一致的空间）
******************************************************************************************/